// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

#include "Constants.h"

#include "commands/LineAlignCommand.h"

LineAlignCommand::LineAlignCommand(Drivetrain* drivetrain)
:m_drivetrain(drivetrain) {

    // Use AddRequirements() here to declare subsystem dependencies
    // eg. AddRequirements(m_Subsystem);
    SetName("LineAlign");
    AddRequirements({m_drivetrain});
}

// Called just before this Command runs the first time
void LineAlignCommand::Initialize() {

    m_lineAlignCompleted = false;

    // left speed, right speed, indicate this is not an operator command
    m_drivetrain->DrivetrainTankMove(Porterbots::LineDetection::kLineAlignSpeed,
                                     Porterbots::LineDetection::kLineAlignSpeed,
                                     Porterbots::Drivetrain::kAutoCommand);
}

// Called repeatedly when this Command is scheduled to run
void LineAlignCommand::Execute() {

    // as a safety check, if for any reason line align is completed and we still
    // got called, don't do anything else except for stopping the robot because
    // this is an unexpected condition
    //
    // doing this here and now could save us a robot crash or some twisty debugging later...
    
    if (m_lineAlignCompleted) {
        m_drivetrain->DrivetrainTankMove(0.0, 0.0, Porterbots::Drivetrain::kAutoCommand);

        return;
    }
        
    // all we want to do is check to see if we've encountered a line
    //
    // once we've seen a line, using either sensor, stop the robot as we're done for now
    //
    // we stop the drivetrain and we set the m_lineAlignCompleted flag to true
    //
    // later we'll want to put the actual alignment logic in here

    if (m_drivetrain->IsLineDetected(Porterbots::LineDetection::kLeftLineSensor) ||
        m_drivetrain->IsLineDetected(Porterbots::LineDetection::kRightLineSensor)) {

        // found a line so for now just stop the robot and set the finished flag

        m_drivetrain->DrivetrainTankMove(0.0, 0.0, Porterbots::Drivetrain::kAutoCommand);

        m_lineAlignCompleted = true;
    }

    // else we just let the robot crawl forward at the kLineAlignSpeed for now

    // we'll check sensors again the next time through this routine
    //
    // doing short quick checks or changes and getting out is a key part
    // of keeping the scheduler (and the entire robot) running as it should be
}

// Make this return true when this Command no longer needs to run execute()
bool LineAlignCommand::IsFinished() {

    // this gets set by the Execute() routine when it reaches the terminal state,
    // that is the robot aligning itself to the alignment line
    //
    // we just return it here as it's been set elsewhere
    return m_lineAlignCompleted;
}

// Called once after isFinished returns true
void LineAlignCommand::End(bool interrupted) {

    // even though we didn't find the line - just set out flag like we're done
    //
    // this is a safety thing mostly
    m_lineAlignCompleted = true;
}

bool LineAlignCommand::RunsWhenDisabled() const {
    return false;
}
