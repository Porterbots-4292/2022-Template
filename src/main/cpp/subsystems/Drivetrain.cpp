// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

#include "subsystems/Drivetrain.h"
#include <frc/smartdashboard/SmartDashboard.h>


Drivetrain::Drivetrain()

#ifdef  NEVER
    // this is where the CAN ID and motor type parameters are set for the REV SparkMax controllers
    //
    // this happens in the Drivetrain constructor so we have to be a little tricky about we get
    // the syntax right - note that the next line starts with a colon and then proceeds to initialize
    // the sparkmax controllers
    //
    // the { at the start of the function follows the conditional code
    : m_leftFrontController{Porterbots::CAN_ID::kMotorLeftFrontID, rev::CANSparkMax::MotorType::kBrushless},
      m_rightFrontController{Porterbots::CAN_ID::kMotorRightFrontID, rev::CANSparkMax::MotorType::kBrushless}
#endif  // SPARKMAX{
    {

    // this sets up a bunch of stats to display on the LiveWindow
    //
    // we probably don't want this much stuff to show up during competition
    // but for robot development and debugging, it can be very useful to see
    // specific components on the robot are actually doing
    SetName("Drivetrain");
#ifndef SPARKMAX
    AddChild("Front_Left Motor", &m_leftFrontController);
    AddChild("Rear Left Motor", &m_leftRearController);
    AddChild("Front Right Motor", &m_rightFrontController);
    AddChild("Rear Right Motor", &m_rightRearController);
#endif // ! SPARKMAX

    SetSubsystem("Diff Drive");
    AddChild("Diff Drive", &m_robotDrive);

    SetSubsystem("Line Sensors");
    AddChild("Left", &m_leftLineSensor);
    AddChild("Right", &m_rightLineSensor);

    // these are parameters that apply to the differential drive (overall)
    m_robotDrive.SetSafetyEnabled(Porterbots::Drivetrain::kSafetyEnabled);
    m_robotDrive.SetExpiration(Porterbots::Drivetrain::kExpirationTime);
    m_robotDrive.SetMaxOutput(Porterbots::Drivetrain::kMaxOutput);
 
    // SetInverted to true reverses the "normal" rotation direction of the associated motor
    // controller or controller group - typicaly this is because motors on different sides
    // of the robot are mounted in different direions but we all want them to spin the
    // appropriate direction for them to all move the robot forward
    //
    // if the robot runs "backwards" after using the SetInverted() settings, just flip the
    // true and false values and the robot will switch it's primary direction of travel
    //
    // many times they properties can be pre-configured in the motor controller as part of
    // its offline configuration but it's best to set any parameters important for the robot
    // in software so that if a controller is replaced, any special settings get configured
    // before it gets used and we don't have to count on someone configuring something at
    // the time the component was replaced - they'll still need to set the CAD ID of the
    // replacement controller but all they need to do is get the address right and we can
    // handle the rest
    //
    // some folks go as far as doing a factory reset in the code and then changing *ONLY* what
    // needs changing - this isn't a bad idea either
    m_leftSideMotors.SetInverted(false);
    m_rightSideMotors.SetInverted(true);
}

void Drivetrain::Drive(double input1, double input2) {
    
    // our default "Drive" routine is Arcade for now but we can change it here if we like
    //
    // this is where the human driver input should go through
    //
    // we can also call the explicit routines to intermingle Arcade and Tank when we want one or
    // the other - could be handy for some command sequences to think about it in one of those ways
    // over the other
    //
    // as to why we're squaring the drive input, it's for smoother control at slow speeds
    //
    // we raise the value of the joystick to this power to implement an exponential curve
    // to the joystick response - this gives us a lot more fine low end control because using a
    // square vakue of 2 means that .5 (half joystick) is really .25 while a full value of 1
    // is 1 (full speed)
    //
    // we can disable "input squaring" by specifying a value of 1.0 for kDriveInputSquareValue
    // in Constants.h
    //
    // note that we need to save the sign of the inputs and reapply it after squaring if we
    // are squaring it - otherwise we can leave it alone
    //
    // the code checking the value of kDriveInputSquareValue coe just make things robust in case
    // we decide to get rid of squaring - we want to make sure we leave the sign alone if
    // we're not squaring

    int signInput1 = 1;
    int signInput2 = 1;

    if (input1 < 0 && Porterbots::Drivetrain::kDriveInputSquareValue != 1.0) {
        signInput1 = -1;
    }

    if (input2 < 0 && Porterbots::Drivetrain::kDriveInputSquareValue != 1.0) {
        signInput2 = -1;
    }

    m_robotDrive.ArcadeDrive(signInput1 * pow(input1, Porterbots::Drivetrain::kDriveInputSquareValue),
                             signInput2 * pow(input2, Porterbots::Drivetrain::kDriveInputSquareValue));
}

void Drivetrain::TankDrive(double leftSpeed, double rightSpeed) {

    m_robotDrive.TankDrive(leftSpeed, rightSpeed);
}

void Drivetrain::ArcadeDrive(double speed, double turn) {

    m_robotDrive.ArcadeDrive(speed, turn);
}

void Drivetrain::Periodic() {
    // Put code here to be run every loop

}

void Drivetrain::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

}


// Put methods for controlling this subsystem
// here. Call these from Commands.

bool Drivetrain::IsLineDetected(int sensor) {

    // defaulting this to true actually means a line is *NOT* detected
    // since the sensor is seeing the IR being reflected from the carpet
    //
    // the black alignment tape actually does not reflect so the sensor
    // returns false to indicate the line has been found
    //
    // this ensure that if a bad sensor identifier is passed, it will return
    // no line - this seems like the safest bet

    bool sensorReading = true;

    switch (sensor) {

        case Porterbots::LineDetection::kLeftLineSensor:

            sensorReading = m_leftLineSensor.Get();
            break;

        case Porterbots::LineDetection::kRightLineSensor:

            sensorReading = m_rightLineSensor.Get();
            break;
    }

    // we invert the return from the sensor because for us, a "true" indicates
    // the line was found
    return ( ! sensorReading);
}


