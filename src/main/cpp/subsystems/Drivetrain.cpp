// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "subsystems/Drivetrain.h"
#include <frc/smartdashboard/SmartDashboard.h>

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

Drivetrain::Drivetrain(){
    SetName("Drivetrain");
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SetSubsystem("Drivetrain");

 AddChild("Differential Drive", &m_differentialDrive);

 m_differentialDrive.SetSafetyEnabled(Porterbots::Drivetrain::kSafetyEnabled);
 m_differentialDrive.SetExpiration(Porterbots::Drivetrain::kExpirationTime);
 m_differentialDrive.SetMaxOutput(Porterbots::Drivetrain::kMaxOutput);
 
 m_leftSideMotors.SetInverted(false);
 m_rightSideMotors.SetInverted(true);
}

void Drivetrain::DrivetrainTankMove(double leftSpeed, double rightSpeed, bool source) {

    m_differentialDrive.TankDrive(leftSpeed, rightSpeed);
}

void Drivetrain::DrivetrainArcadeMove(double speed, double turn, bool source) {

    m_differentialDrive.ArcadeDrive(speed, turn);
}

void Drivetrain::Periodic() {
    // Put code here to be run every loop

}

void Drivetrain::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

}


// Put methods for controlling this subsystem
// here. Call these from Commands.

bool Drivetrain::IsLineDetected(int sensor) {

    // defaulting this to true actually means a line is *NOT* detected
    // since the sensor is seeing the IR being reflected from the carpet
    //
    // the black alignment tape actually does not reflect so the sensor
    // returns false to indicate the line has been found
    //
    // this ensure that if a bad sensor identifier is passed, it will return
    // no line - this seems like the safest bet

    bool sensorReading = true;

    switch (sensor) {

        case Porterbots::LineDetection::kLeftLineSensor:

            sensorReading = m_leftLineSensor.Get();
            break;

        case Porterbots::LineDetection::kRightLineSensor:

            sensorReading = m_rightLineSensor.Get();
            break;
    }

    // we invert the return from the sensor because for us, a "true" indicates
    // the line was found
    return ( ! sensorReading);
}

// allow operator commands
//
// this is normally the case but there are times when we don't want the operator to be able
// to send movement commands so this will suppress those movements

void SetAllowOperatorCommands(bool) {

}

bool GetAllowOperatorCommands() {

    return true;            // for now...
}

